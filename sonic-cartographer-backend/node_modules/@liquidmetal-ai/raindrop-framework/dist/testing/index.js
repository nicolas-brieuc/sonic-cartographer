/**
 * Testing utilities for Raindrop applications
 *
 * This module provides mock implementations and factory functions for all Raindrop bindings
 * for use in tests. Import these in your test files to create isolated
 * test environments without needing real Cloudflare Workers infrastructure.
 *
 * @example
 * ```typescript
 * import { createMockEnv, createMockActorState } from '@liquidmetal-ai/raindrop-framework/testing';
 *
 * test('my handler', async () => {
 *   const env = createMockEnv();
 *   const state = createMockActorState();
 *   const actor = new MyActor(state, env);
 *   // ... test actor methods
 * });
 * ```
 */
import { vi } from 'vitest';
// ============================================================================
// ActorStorage Mock
// ============================================================================
/**
 * In-memory implementation of ActorStorage for testing
 */
export class MockActorStorage {
    data = new Map();
    alarm = null;
    async get(keyOrKeys) {
        if (Array.isArray(keyOrKeys)) {
            const result = new Map();
            for (const key of keyOrKeys) {
                const value = this.data.get(key);
                if (value !== undefined) {
                    result.set(key, value);
                }
            }
            return result;
        }
        return this.data.get(keyOrKeys);
    }
    async list(options) {
        const result = new Map();
        const entries = Array.from(this.data.entries());
        // Sort entries by key
        entries.sort(([a], [b]) => a.localeCompare(b));
        let filteredEntries = entries;
        // Apply filters
        if (options?.prefix) {
            filteredEntries = filteredEntries.filter(([key]) => key.startsWith(options.prefix));
        }
        if (options?.start) {
            filteredEntries = filteredEntries.filter(([key]) => key >= options.start);
        }
        if (options?.startAfter) {
            filteredEntries = filteredEntries.filter(([key]) => key > options.startAfter);
        }
        if (options?.end) {
            filteredEntries = filteredEntries.filter(([key]) => key <= options.end);
        }
        if (options?.reverse) {
            filteredEntries.reverse();
        }
        if (options?.limit) {
            filteredEntries = filteredEntries.slice(0, options.limit);
        }
        for (const [key, value] of filteredEntries) {
            result.set(key, value);
        }
        return result;
    }
    async put(keyOrEntries, value) {
        if (typeof keyOrEntries === 'string') {
            this.data.set(keyOrEntries, value);
        }
        else {
            for (const [key, val] of Object.entries(keyOrEntries)) {
                this.data.set(key, val);
            }
        }
    }
    async delete(keyOrKeys) {
        if (Array.isArray(keyOrKeys)) {
            let count = 0;
            for (const key of keyOrKeys) {
                if (this.data.delete(key)) {
                    count++;
                }
            }
            return count;
        }
        return this.data.delete(keyOrKeys);
    }
    async deleteAll() {
        this.data.clear();
    }
    async getAlarm() {
        return this.alarm;
    }
    async setAlarm(scheduledTime) {
        this.alarm = typeof scheduledTime === 'number' ? scheduledTime : scheduledTime.getTime();
    }
    async deleteAlarm() {
        this.alarm = null;
    }
    // Test helpers
    clear() {
        this.data.clear();
        this.alarm = null;
    }
    getAllData() {
        return new Map(this.data);
    }
}
// ============================================================================
// ActorState Mock
// ============================================================================
/**
 * Mock implementation of ActorState for testing
 */
export class MockActorState {
    storage;
    id;
    waitUntilPromises = [];
    constructor(id, storage) {
        this.storage = storage || new MockActorStorage();
        this.id = {
            toString: () => id || 'mock-actor-id',
            equals: (other) => other.toString() === this.id.toString(),
            name: id,
        };
    }
    waitUntil(promise) {
        this.waitUntilPromises.push(promise);
    }
    async blockConcurrencyWhile(callback) {
        return callback();
    }
    // Test helper to wait for all waitUntil promises
    async flushWaitUntil() {
        await Promise.all(this.waitUntilPromises);
        this.waitUntilPromises = [];
    }
}
// ============================================================================
// ExecutionContext Mock
// ============================================================================
/**
 * Mock implementation of ExecutionContext for testing
 */
export class MockExecutionContext {
    promises = [];
    waitUntil(promise) {
        this.promises.push(promise);
    }
    // Test helper to wait for all waitUntil promises
    async flushWaitUntil() {
        await Promise.all(this.promises);
        this.promises = [];
    }
}
// ============================================================================
// Mock Factory Functions (using vi.fn())
// ============================================================================
/**
 * Creates a mock KvCache using vitest mocks
 * All methods are vi.fn() which can be customized per test
 */
export function createMockKvCache() {
    return {
        get: vi.fn().mockResolvedValue(null),
        getWithMetadata: vi.fn().mockResolvedValue({ value: null, metadata: null, cacheStatus: null }),
        put: vi.fn().mockResolvedValue(undefined),
        delete: vi.fn().mockResolvedValue(undefined),
        list: vi.fn().mockResolvedValue({ keys: [], list_complete: true, cacheStatus: null }),
        clear: vi.fn().mockResolvedValue({ deleted: 0, total: 0 }),
    };
}
/**
 * Creates a mock Logger using vitest mocks
 * All methods are vi.fn() which can be customized per test
 */
export function createMockLogger() {
    const mockLogger = {
        logs: [],
        with: vi.fn(),
        log: vi.fn(),
        logAtLevel: vi.fn(),
        message: vi.fn(),
        messageAtLevel: vi.fn(),
        debug: vi.fn(),
        info: vi.fn(),
        warn: vi.fn(),
        error: vi.fn(),
        withError: vi.fn(),
    };
    // Make with() and withError() return the logger for chaining
    mockLogger.with.mockReturnValue(mockLogger);
    mockLogger.withError.mockReturnValue(mockLogger);
    // Capture logs in the logs array for testing
    mockLogger.log.mockImplementation((message, fields) => {
        mockLogger.logs.push({ level: 'log', message, fields });
    });
    mockLogger.logAtLevel.mockImplementation((level, message, fields) => {
        mockLogger.logs.push({ level, message, fields });
    });
    mockLogger.debug.mockImplementation((message, fields) => {
        mockLogger.logs.push({ level: 'debug', message, fields });
    });
    mockLogger.info.mockImplementation((message, fields) => {
        mockLogger.logs.push({ level: 'info', message, fields });
    });
    mockLogger.warn.mockImplementation((message, fields) => {
        mockLogger.logs.push({ level: 'warn', message, fields });
    });
    mockLogger.error.mockImplementation((message, fields) => {
        mockLogger.logs.push({ level: 'error', message, fields });
    });
    // message() and messageAtLevel() return LogMessage objects
    mockLogger.message.mockImplementation((message, fields) => ({
        level: 'info',
        message,
        fields: fields || {},
    }));
    mockLogger.messageAtLevel.mockImplementation((level, message, fields) => ({
        level,
        message,
        fields: fields || {},
    }));
    return mockLogger;
}
/**
 * Creates a mock Tracer using vitest mocks
 */
export function createMockTracer() {
    const mockTracer = {
        spans: [],
        span: vi.fn(),
    };
    // Implement span to capture spans and execute the function
    mockTracer.span.mockImplementation(async (name, fn) => {
        const event = {};
        mockTracer.spans.push({ name, event });
        return fn(event);
    });
    return mockTracer;
}
/**
 * Creates a mock Bucket using vitest mocks
 */
export function createMockBucket() {
    return {
        head: vi.fn().mockResolvedValue(null),
        get: vi.fn().mockResolvedValue(null),
        put: vi.fn().mockResolvedValue({}),
        delete: vi.fn().mockResolvedValue(undefined),
        list: vi.fn().mockResolvedValue({ objects: [], truncated: false, delimitedPrefixes: [] }),
    };
}
/**
 * Creates a mock Queue using vitest mocks
 * Includes helpers for creating mock Message and MessageBatch objects
 */
export function createMockQueue() {
    const mockQueue = {
        send: vi.fn().mockResolvedValue(undefined),
        sendBatch: vi.fn().mockResolvedValue(undefined),
        // Helper to create mock Message for testing queue consumers
        createMockMessage(body, id) {
            return {
                id: id || `msg-${Date.now()}-${Math.random()}`,
                timestamp: new Date(),
                body,
                attempts: 1,
                retry: vi.fn(),
                ack: vi.fn(),
            };
        },
        // Helper to create mock MessageBatch for testing batch queue consumers
        createMockMessageBatch(bodies, queueName = 'test-queue') {
            const messages = bodies.map((body, i) => mockQueue.createMockMessage(body, `msg-${i}`));
            return {
                messages,
                queue: queueName,
                retryAll: vi.fn(),
                ackAll: vi.fn(),
            };
        },
    };
    return mockQueue;
}
// ============================================================================
// Helper Functions
// ============================================================================
/**
 * Creates a mock Env object with all standard bindings
 *
 * @param overrides Partial Env object to override defaults
 * @returns Mock Env object for testing
 *
 * @example
 * ```typescript
 * const env = createMockEnv({
 *   MY_SMARTBUCKET: createMockBucket(),
 *   MY_CACHE: createMockKvCache(),
 * });
 * ```
 */
export function createMockEnv(overrides) {
    const baseEnv = {
        _raindrop: {
            app: {
                organizationId: 'test-org',
                applicationName: 'test-app',
                versionId: 'test-version',
                scriptName: 'test-script',
                visibility: 'public',
            },
        },
        logger: createMockLogger(),
        tracer: createMockTracer(),
        mem: createMockKvCache(),
    };
    return { ...baseEnv, ...overrides };
}
/**
 * Creates a mock ActorState for testing Actor handlers
 *
 * @param id Optional actor ID (defaults to 'mock-actor-id')
 * @param storage Optional MockActorStorage instance
 * @returns MockActorState instance
 *
 * @example
 * ```typescript
 * const state = createMockActorState('my-actor-1');
 * const actor = new MyActor(state, env);
 * ```
 */
export function createMockActorState(id, storage) {
    return new MockActorState(id, storage);
}
/**
 * Creates a mock ExecutionContext for testing Service and Task handlers
 *
 * @returns MockExecutionContext instance
 *
 * @example
 * ```typescript
 * const ctx = createMockExecutionContext();
 * const service = new MyService(ctx, env);
 * ```
 */
export function createMockExecutionContext() {
    return new MockExecutionContext();
}
