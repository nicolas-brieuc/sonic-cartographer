import { JWTVerifyResult } from '@liquidmetal-ai/noway';
import type { Payments } from '../payments.js';
type Env = {
    payments: Payments;
    jwt?: JWTVerifyResult<{
        metadata?: {
            [key: string]: string;
        };
    }>;
    logger?: {
        info: (msg: string, ...args: unknown[]) => void;
        warn: (msg: string, ...args: unknown[]) => void;
        error: (msg: string, ...args: unknown[]) => void;
    };
    ctx: ExecutionContext;
};
interface ExecutionContext {
    waitUntil(promise: Promise<unknown>): void;
    passThroughOnException(): void;
}
/**
 * Payment verification interceptor for paid services.
 *
 * This function acts as a payment gate, similar to how verifyIssuer acts as an auth gate.
 * It should be called AFTER authentication (verifyIssuer) and authorization (requireAuthenticated).
 *
 * Validates that:
 * 1. User has valid JWT with metadata (fast path)
 * 2. Subscription status is 'active' for the specific product
 * OR
 * 3. Falls back to Stripe API lookup if JWT metadata is missing/stale (handles race conditions)
 *
 * Expected JWT metadata structure (flattened with product_id prefix):
 * {
 *   "prod_123_customer_id": "cus_456",
 *   "prod_123_status": "active",
 *   "prod_789_customer_id": "cus_abc",
 *   "prod_789_status": "cancelled"
 * }
 *
 * This structure allows a single user to have multiple product subscriptions.
 * WorkOS requires flat metadata with string values, so we use prefixed keys.
 *
 * Race condition handling:
 * If JWT was issued before webhook updated WorkOS metadata, this will query Stripe directly
 * to check for active subscriptions. This adds latency but ensures paying users get access.
 * The WorkOS metadata is then "healed" in the background using ctx.waitUntil().
 *
 * IMPORTANT: When calling verifyPayment from a Service, you must pass this.ctx:
 *
 * Example usage in a Service:
 * ```typescript
 * const hasAccess = await verifyPayment(request, {
 *   payments: this.env.payments,
 *   jwt: this.env.jwt,
 *   logger: this.env.logger,
 *   ctx: this.ctx  // â† REQUIRED: pass execution context from Service
 * });
 * ```
 *
 * @param request The incoming request object.
 * @param env The environment object containing payments binding, JWT, and execution context.
 * @returns True if user has active subscription for this product, false otherwise.
 */
export declare const verifyPayment: (request: Request, env: Env) => Promise<boolean>;
export {};
//# sourceMappingURL=payment.d.ts.map